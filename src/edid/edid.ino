// 1. Deliver a customized EDID to the host computer
// 2. Create a CSYNC signal from HSYNC/VSYNC
// Uses an Attiny1604, with standard I2C wiring.
// Set to turn off millis() timer and clock speed must be 20MHz 

void setup() 
{
  CLKCTRL.MCLKCTRLB = B00000000; // use full system clock for peripherials
  pinMode(8, INPUT); // pin A1 (HSYNC)
  pinMode(9, INPUT); // pin A2 (VSYNC)
  pinMode(0, OUTPUT);  // CSYNC
  digitalWrite(0,LOW);

  pinMode(7,INPUT_PULLUP); // pin B0 (SCL)
  pinMode(6,INPUT_PULLUP); // pin B1 (SDA)

  pinMode(3,OUTPUT);
  digitalWrite(3,HIGH); // pin A7 (hot-plug detect)
  
  calculate_checksums();    
  startcsync();
  starti2c();
}


void startcsync()
{
  // set up sync channel 0 to feed the hsync input pin into timer A  
  EVSYS.SYNCCH0 = 0x0E;    // HSYNC from pin A1
  EVSYS.SYNCUSER1 = 0x01; // timer A uses sync channel 0
  // configure timer A to count while its event input (HSYNC) is high
  TCA0.SINGLE.CTRLD = B00000000; // no split mode
  TCA0.SINGLE.CTRLA = B00000001; // enable counting at full speed
  TCA0.SINGLE.CTRLB = B00000000; // just counting, no waveform generation
  TCA0.SINGLE.CTRLECLR = B00000011; // count upwards
  TCA0.SINGLE.EVCTRL = B00000101;  // count while event input is high
  TCA0.SINGLE.INTCTRL = B00000000; // no interrupts
  TCA0.SINGLE.CNT = 0;             // default init
  TCA0.SINGLE.PER = 0xFFFF;        // may count as far as it goes
  // set up async channel 0 to feed the hsync input pin into timer B and to LUT0
  EVSYS.ASYNCCH0 = 0x0B;   // HSYNC from pin A1
  EVSYS.ASYNCUSER0 = 0x03; // timer B uses async channel 0 as input  
  EVSYS.ASYNCUSER2 = 0x03; // LUT0/EV0 uses async channel 0
  // configure timer B to generate a longer pulse for each incomming HSYNC
  TCB0.CCMP = 300;         // dummy duration of single-shot pulse  
  TCB0.CTRLA = B00000001;  // enable timer B at full speed
  TCB0.CTRLB = 0x16;       // single-shot mode
  TCB0.EVCTRL = B01000001;  // start at positive edge
  // combine signals in asynchronous LUT
  CCL.LUT0CTRLB   = 0x73;       // input 1 from from timer B and HSYNC via its event source 0  
  CCL.LUT0CTRLC   = 0x00;       // don't use
  CCL.TRUTH0      = B10101010;  // truth table to take HSYNC directly 
  CCL.LUT0CTRLA   = B00001001;  // enable LUT0 and dedicated output pin
  CCL.CTRLA = B00000001;        // enable CCL  
}

void loop() 
{
    uint16_t t;
    // wait for falling edge on HSYNC (A1)
    while (PORTA.IN & B00000010);
    t = 700; // TCA0.SINGLE.CNT;
    TCA0.SINGLE.CNT = 0;
    TCB0.CCMP = t;  // use the time measured by TCA to use for the TCB pulse duration
    CCL.CTRLA = B00000000;   // disable CCL to modify the LUT definition
    CCL.LUT0CTRLA = B00000000;  // disable LUT0 and dedicated output pin
    // when not in VSYNC (A2), revert to straight HSYNC use
    if (!(PORTA.IN & B00000100))
    {
      CCL.TRUTH0 = B10101010;
      CCL.LUT0CTRLA = B00001001;  
      CCL.CTRLA = B00000001;
      while (!(PORTA.IN & B00000010));  // after change wait for rising HSYNC
    }
    // when in VSYNC combine HSYNC and extended HSYNC
    else
    {
      while (!(PORTA.IN & B00000010)); // do change after rising HSYNC
      CCL.TRUTH0 = B00100010;
      CCL.LUT0CTRLA = B00001001;  
      CCL.CTRLA = B00000001;      
    }
}



// EDID data blocks for HDMI injection
uint8_t edid50hz[256] = {
  0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x0d,0xf0,0x01,0x00,0x01,0x00,0x00,0x00,0x0a,0x22,0x01,0x03,  
  0xa0,0x28,0x1e,0x78,0x26,
  0xEE,0x91,0xA3,0x54,0x4C,0x99,0x26,0x0F,0x50,0x54,
  0x00,0x00,0x00,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x88,0x0a,0xa0,0x20,0x51,0x20,0x18,0x10,0x18,0x80,0x33,0x00,0x90,0x2c,0x11,0x00,0x00,0x18,
  0x00,0x00,0x00,0xfc,0x00,0x48,0x44,0x4d,0x49,0x32,0x53,0x43,0x41,0x52,0x54,0x0a,0x20,0x20,
  0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x00,
  
  0x02,0x03,0x14,0x40,   // header: support basic audio, 0 native formats
  0x23,0x09,0x07,0x07,   // AUDIO data block
  0x83,0x01,0x20,0x20,   // speaker allocation
  0x67,0x03,0x0c,0x00,0x20,0x00,0x00,12, // 0x21,  // vendor specific 
  
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
// EDID type A:
// 02 03 1b 61                 header: support basic audio, YCBCR 4∶4∶4, 1 native format
// 43 90 84 02                 VIDEO VDB
// 23 09 07 07                 AUDIO data block
// 83 01 20 20                 speaker allocation
// 67 03 0c 20 20 20 80 28     vendor specific
// e2 20 0f                    extended tag
// EDID type C:
// 02 03 1b 41                 // header: support basic audio, 1 native formats
// 23 09 07 07                 // audio data block
// 83 01 00 00                 // speaker allocation
// 67 03 0c 00 20 00 00 21 
// 43 10 04 03                 // video VDB
// e2 00 0f                    // extended tag

uint8_t edid60hz[256] = {
  0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x0d,0xf0,0x01,0x00,0x01,0x00,0x00,0x00,
  0x0a,0x22,0x01,0x03,0xa2,0x28,0x1e,0x78,0x26,0xEE,0x91,0xA3,0x54,0x4C,0x99,0x26,
  0x0F,0x50,0x54,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x88,0x0a,0xa0,0x20,0x51,0xf0,0x16,0x00,0x18,0x80,
  0x33,0x00,0x90,0x2c,0x11,0x00,0x00,0x18,0x00,0x00,0x00,0xfc,0x00,0x48,0x44,0x4d,
  0x49,0x32,0x53,0x43,0x41,0x52,0x54,0x0a,0x20,0x20,0x00,0x00,0x00,0x10,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,

  0x02,0x03,0x0C,0x61,
  0x23,0x09,0x07,0x07,
  0x83,0x01,0x20,0x20,
  0x88,0x0a,0xa0,0x20,0x51,0xf0,0x16,0x00,0x18,0x80,0x33,0x00,0x90,0x2c,0x11,0x00,0x00,0x18,
  0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


void calculate_checksums()
{
  uint8_t cs1 = 0;
  uint8_t cs2 = 0;
  uint8_t cs3 = 0;
  uint8_t cs4 = 0;
  uint8_t i;
  for (i=0; i<127; i++)
  {
      cs1 += edid50hz[i];
      cs2 += edid50hz[128+i];
      cs3 += edid60hz[i];
      cs4 += edid60hz[128+i];
  }
  edid50hz[127] = 0 - cs1;
  edid50hz[255] = 0 - cs2;
  edid60hz[127] = 0 - cs3;
  edid60hz[255] = 0 - cs4;
}

uint8_t registeraddress = 0;
bool didreceiveaddress = false;

void starti2c()
{
  pinMode(6, INPUT_PULLUP);
  pinMode(7, INPUT_PULLUP);
  TWI0.CTRLA       = B00011100;  // most conservative behaviour
  TWI0.SCTRLB      = B00000000;  // standard ACK behaviour
  TWI0.SADDR       = B10100000;  // client address $50, no response to "general call address"
  TWI0.SCTRLA      = B11100011;  // enable TWI client in smart mode and allow interrupts  
}

ISR(TWI0_TWIS_vect)
{
  switch (TWI0.SSTATUS & B11000011)
  {
  case B01000001:     // address interrupt for writing
    didreceiveaddress = false;
    break;
  case B10000000:     // data interrupt when writing
  case B10000001:
    if (! didreceiveaddress) 
    {
      registeraddress = TWI0.SDATA;   // already does ACK
      didreceiveaddress = true;
      return;
    }
    break;
  case B10000010:     // data interrupt when reading
  case B10000011:
    // check if using 50Hz mode
    if (true) { TWI0.SDATA = edid50hz[registeraddress]; }  // already does ACK
    else      { TWI0.SDATA = edid60hz[registeraddress]; }  // already does ACK
    registeraddress++;
    return;
  }
  TWI0.SCTRLB = 0x03;  // acknowledge every other case
}
